알고리즘 저장소
=================
- [백준 - Platinum V](https://solved.ac/profile/sjh910805) 
     
     
     <img src="http://mazassumnida.wtf/api/v2/generate_badge?boj=sjh910805">
- [프로그래머스 - Lv3](https://career.programmers.co.kr/pr/sjh910805_1792)

-------------------
### 문제 리스트
- 다른거 하지 말고 최우선 순위로 딱 여기까지만 선 그어놓고 이 안에서 하자
	- [x] 프로그래머스 레벨2 기출문제 풀기
	- [x] 프로그래머스 레벨2 기출문제 다시 풀기. 한번에 안풀리는 문제 기록
	- [x] 프로그래머스 레벨3 기출문제 풀기
	- [ ] 프로그래머스 레벨3 기출문제 다시 풀기. 한번에 안풀리는 문제 기록
	- [ ] 레벨2, 레벨 3 기록 해둔 문제 다시 풀기. 한번에 안풀리는 문제 기록
	- [ ] 레벨2, 레벨 3 기록 해둔 문제 다시 풀기. 한번에 안풀리는 문제 기록
	- [ ] 프로그래머스 레벨4 기출문제 풀기
- 프로그래머스 레벨2 다시 풀 문제 (2회차)
	- 순위검색
- 프로그래머스 레벨3 다시 풀 문제 (2회차)
	- 경주로 건설, 다단계 칫솔 판매
	- 표 편집

- 랜덤 디펜스 후 취약 알고리즘 공략
	- [x] 트리 : 4803, 15681, 1240, 20955, 14267, 2250
	- [x] 유니온 파인드 : 1717, 1976, 4195, 20040
	- [x] 최소 신장 트리 : 9372 4386 1774 6497 17472
	- [x] LCS : 9251, 9252, 1958
	- [x] LIS : [개념](https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4), 11053, 11722, 2565, 14002, 11054, 12015, 12738
	- [x] LIS2 : 18353, 2550, 1365, 3745, 3066
	- [x] 트리 + 재귀 : 9934, 26260, 6597, 4256, 2263
	- [x] 트리 + DP : 15681, 2533, 1949, 2213
	- [x] 트라이 : 14426, 5052, 16934, 14725, 7432, 9202, 16906
	- [x] 우선순위큐 : 2075, 1715, 13975, 1655, 1781, 프그(디스크컨트롤러)
	- [ ] 스택 : 2493, 6198, 17298, 17299, 6549, 1725, 3015
	- [ ] 종만북 DP 다시 보고 와. 2293번을 top-down 방식으로 해결한 풀이법이 도저히 안보이네
	- [ ] DP : ~~2748, 9655, 9657, 1788, 4883, 2302~~, 2293, 2294, 2011
	- [ ] DP2 : 2240, 15486, 1915, 1520, 2482
	- [ ] 게임이론 : 9656, 9658, 9659, 9660, 9661, 2600, 12107, 11062
	- [ ] 우선순위큐+그리디 : 1417, 15903, 11000, 1374, 13904
	- [ ] 최소 공통 조상 : 2584, 11437, 11812, 2233, 10838, 11438
	- [ ] 세그먼트 트리

- 예전에 못풀었지만 다시 시도할 문제
	- [x] 9084, 3067, 1958
	- [ ] ~~2263~~, 2447, 2448, ~~1377, 1939~~
	- [ ] 프로그래머스 gps(DP)
	- [ ] 2042, 13325 (세그먼트 혹은 바이너리 인덱스트리)
	- [x] 14003, 13711 (Platinum LIS 문제)
	- [ ] 1135 (그리디 + dp + 트리)
	- [ ] 프로그래머스 124나라
	- [ ] 프로그래머스 자동완성 (트라이)


- 기출 및 선별 문제 모음
     	- [바킹독 문제집](https://github.com/encrypted-def/basic-algo-lecture/blob/master/workbook.md)
	- ~~[ ] 백준 삼성 기출~~
	- ~~[ ] 프로그래머스 lv5 문제~~
	- ~~[ ] 프로그래머스 lv5 테스트~~
	- ~~[ ] 백준 class6~~
	- ~~[ ] 백준 class7~~
----------
### 상황별 공부법
- 평소
    - 프로그래머스 레벨2, 레벨3 기출문제는 현재 81문제. 레벨 4까지는 100문제. 그냥 이 100문제를 완전히 머리속에 넣고 그 이후를 욕심내자
    - 양치기로 승부하려 하지마. 양을 줄이고, 개념을 확실히 학습해야돼. 
    - 너무 어려운 알고리즘 문제 풀다가 간단한 스택 문제도 못푸는 바보짓 하면 안돼.
    - 목표는 기업 코테 통과이지 알고리즈 대회 수상이 아니야.
    - ~~세그먼트 트리, 기하, 라빈 카프, 유량, SCC, BCC, 게임 이론 등 다양한 알고리즘 익혀가기..~~
    - ~~코드 포스, 앳코드, 탑코더 등 대회 참여. (영어 주의...)~~
- 풀이법을 봐도 모르겠는 경우 
    1. 쉼호흡 한번 하고 겸손한 마음으로 정답 코드를 천천히 타이핑하고 노트에 그려가며 작동 원리를 이해한다.
    2. 이해 했다면, 풀이를 보지 않고 내가 직접 풀어본다.
    3. 죽어도 이해가 안간다면, 난이도가 낮고 비슷한 유형의 문제를 5개 더 풀고 다시 풀이 도전한다.
- 풀이법을 보든 어찌하든 어렵게 해결한 문제는 다음날 다시 한번 더 풀어본다.
- 외부 ide 금지, 구글링 금지시 외워야 할것
	- 우선순위큐오름차순
	- 문자열 파싱
	- #include <bits/stdc++.h>
	- floor() round() ceil() trunc()

-------
### STL
- 이분탐색
	- lower_bound(v.begin(), v.end(), value); : v배열에서 value보다 크거나 같은 수 중 가장 첫번째 수의 반복자 반환
	- upper_bound(v.begin(), v.end(), value); : v배열에서 value보다 큰 수 중 가장 첫번째 수의 반복자 반환
	- binary_search(v.begin(), v.end(), value); : v배열에 value가 있나 없나 bool 반환
- v.size() 의 타입은 unsigned int 임
	- 또한 int 타입의 피연산자와 연산을 할 경우, 해당 피연산자가 unsigned int로 형변환됨.
	- for(int i = 0; i < v.size()-1; i++)
		- v.size() 가 0일 경우 v.size()-1이 -1이 되어 for문이 실행 안되는게 아니라, 엄청큰 양수가 되어서 for문 많이 실행됨.
	- for(int i = -2; i < v.size(); i++)
		- v.size()와 i가 비교 연산 할때 i가 unsigned int로 형변환되면서 엄청 큰 수가 되고 v.size()보다 웬만하면 큰값이기에 for문 실행 안됨.
	- 결론: v.size()-n가 음수가 될것 같거나, i가 음수부터 시작된다거나 하는 상황에서는 (int)v.size() 사용하자.
- 1e9, 2e9 이게 사실 double형임!
	- int num = 1e9; 는 소수점 날리고, int형으로 자동 형변환되어 들어가지만,
	- int num[2] = {1e9, 1e9}; 이건 불가. 따로 casting 해줘야함
	- int num[2] = {(int)1e9, (int)1e9};

- gcd(a, b), lcm(a, b)
	- 최대공약수, 최소공배수 함수 있어.
	- gcc 내장 함수로 있어서 지금 내 vscode에서 디버깅하면 오류남. run은 오류 안남.
	- c++17부터는 numberic 헤더가 들어감.
	- 가장 중요한건 프로그래머스에서 실행 가능함.
- string의 find 메소드의 반환값
	- str.find("aaa") 을 하면 str 문자열에서 가장 앞에 있는 패턴문자열의 위치를 반환함.
	- 반환 타입이 idx가 아니긴 한데, int idx = str.find("aaa"); 라고 해주면 int 형으로 잘 바꿔서 반환해줌
	- 만약 패턴을 못찾았을 경우에는 idx에 -1이 들어감.
	- int로 변환하지 않으면 string::npos 라는 값으로 나오는데 이걸 print하면 아주 엄청난 수가 나옴. 
	- string::npos랑 -1은 분명 다른 수로 출력되는데 if(string::npos == -1) 이라고 하면 true 반환.
	- 연산 과정에서 int로 바꿔주는듯.

- priority_queue
    - 가장 큰 값이 top()으로 반환됨
    - vs Set
    - set은 균형잡힌 이진검색 중 하나인 레드블랙 트리로 구현되어 있고, 우선순위 큐는 완전이진트리인 힙으로 구현.
     - 완전 이진 트리
        - 모든 노드에 저장된 값은 자식 노드에 저장된 값보다 크거나 같아야 한다. 
        - 즉, 부모노드가 자식노드보다 크다는것만 보장하고, 형제노드 삼촌노드와의 우선순위는 보장 못해.
     - 때문에 set은 반복자 for문으로 순차적으로 조회할 수 있지만, 우선순위큐는 순차적으로 조회하려면 while 돌리면서 top, pop 했던거네.
    
- max_element()
    - 시간복잡도 O(n)임. 그냥 선형으로 가장 큰 값 찾아서 반복자 반환

- sort()
     - vector<vector<int>> v 을 정렬시킬 경우, 2차원의 요소들은 정렬의 기준이 되지만, 걔네들이 재 배열 되는건 아니야. 1차원 내에서 재배열 되는거지.
     - 1차원의 요소 까지 정렬 시키리면, for(auto &x: v) sort(x.begin(), x.end()); 해줘야함. x를 참조 형태로 받지 않으면 당연히 배열 해놓고 적용 안됨!!
    
---------
### 알고리즘별 요약 및 풀이 전략

- 백트래킹
  - '종만북'에서 굳이 백트래킹을 다른 챕터로 두어 다루지 않았던 이유는 종만북에서 소개한 완전탐색에서 이미 그 개념을 포함하여 함수를 구현했기 때문인듯하다.
  - 더 이상 탐색을 할 필요 없는 상황에서 탐색을 멈추는것을 백트래킹이라 하는데, 사실상 내가 알고있는 재귀를 활용한 완전탐색 함수에서 기저사례를 두는것이 이 개념과 동일하다.
  
- 시뮬레이션
  - 풀이법에 특정 알고리즘이 필요한것이 아니라 그냥 빡구현 하는 문제를 시뮬레이션이라 분류한다.
 
- DP
  - 동적 계획법(DP) : 두 번 이상 반복 계산 되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법
  - 풀이법에는 Top-Down 방식과 Bottom-Up 방식이 있다.
  - Top-Down 방식은 재귀를 통해, Bottom-Up 방식은 배열과 for문을 통해 구현할 수 있다.
  - bottom-up
	- 장점
		- top-down보다 빠르게 동작 
		- 테이블을 정의하고 점화식을 추론하는 과정이 상대적으로 편이. 테이블을 채우다보면 패턴을 파악하여 점화식을 도출 할 수 있기에.
	- 단점 
		- 테이블을 채우는 순서를 내가 잘 생각해서 그 순서대로 채우게끔 코드를 짜야한다. 즉 테이블과 점화식 정의 후 for문과 초기값 설정이 어려울때가 있음.
  - Top-Down
	- 장점 
		- 재귀를 활용한 완전탐색으로 문제를 풀다가 시간복잡도가 너무 크다 싶으면, 메모이제이션을 활용하면서 자연스럽게 top-down 형태로 문제를 풀수가 있게 되니, 생각의 흐름이 조금 더 자연스럽고 직관적이다.
	- 단점
		- 성능이 조금 떨어짐. 성능이 경계면에 있을때 아주 가~~끔 bottom-up으로 풀리는데 top-down으로 안풀리는 문제가 10000문제중에 하나 존재 하는듯.
  - 결론 : 테이블을 채우는 순서가 직관적으로 보일 때에는 bottom-up을 쓰고, 순서가 헷갈릴땐 top-down으로 푸는 방식으로 해보자.
  - **Bottom-UP 풀이법**
	  - 1_ 테이블을 정의한다. ex) d[x] = x번째 계단까지 올랐을때 얻을 수 있는 최댓값
	  - 2_ 점화식을 세운다. ex) d[x] = max(d[x-1], d[x-2]) + cost[x];
	  - 3_ 초기값을 설정한다. ex) d[1] = cost[1], d[2] = cost[2];
	  - 4_ for문 돌린다.
  - Tip
	- 1_ 테이블 정의 후 점화식이 도출 안되면, 일단 테이블을 채워본 후 규칙성을 찾는다. 도저히 규칙성이 안나오면 1차 배열이 아니라 2차 배열일 수도 있다.
	- 2_ 0-indexed 보다 1-indexed가 조금 더 편하다.
	- 3_ 구현 순서상 초기값 설정이 for문보다 먼저 나와야 하지만, 바로 초기값이 안떠오를 경우 for문을 먼저 작성해보고 거기에서 힌트를 얻어 초기값을 설정해도 된다.
  - **Top-Donw 풀이법**
    - 1_ 앞으로 남은 선택들에 해당하는 결과들을 반환하도록 함수를 잘~ 정의
    - 2_ 점화식 구성
    - 3_ 기저사례들을 정리
    - 4_ 메모이제이션 적용해서 함수 구현
  - 메모이제이션은 참조적 투명 함수의 경우에만 적용 가능.
     - ~~참조적 투명 함수 : 입력이 고정 되어 있을때 그 결과가 항상 같은 함수~~
  - ~~두 가지 모두에 익숙해 지려 하지 말고, 한 가지 방식으로만 판다.~~
  - ~~전반적으로 성능면에서 Top-Down 방식이 손해가 있긴 하다.~~
  - ~~다만, 재귀를 활용한 완전탐색으로 문제를 풀다가 시간복잡도가 너무 크다 싶으면, 메모이제이션을 활용하면서 자연스럽게 top-down 재귀형태로 문제를 풀수가 있게 되니, 생각의 흐름이 조금 더 자연스럽고 직관적이다.~~
  - ~~따라서 나는 일단은 Top-Down 방식으로 연습한다.~~
  - ~~유감스럽게도 구글링 했을때 나오는 풀이법들로는 Bottom-Up 방식이 많긴 하다.~~
  - ~~도저히 Top-Down으로 해결이 안되는데, 억지로 붙들지 말고 그냥 해당 유형의 문제는 Bottom-UP으로 풀어...~~
  - ~~Bottom-up으로 푸는 문제..~~
  	- ~~[동전1](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/0e01b2a2224fee0e38f544a92ee6c4e451a1aae5/%EB%B0%B1%EC%A4%80/Gold/2293.%E2%80%85%EB%8F%99%EC%A0%84%E2%80%851)~~
    
- 그리디
  - 100% 신뢰할만한 풀이법이 떠오르지 않은 상태라면, 일단 스킵하고 마지막에 푼다.
  - 100% 신뢰할만한 풀이법으로 구현을 했는데 틀렸다면, 일단 스킵하고 마지막에 푼다. 
  - 풀이법이 틀렸는지, 구현을 잘못했는지 확인할 수 없기 때문.
  - 떠올린 풀이법에서 **'지금 당장은 손해보더라도, 나중가서 이득을 볼 수 있는 상황이 있는 것은 아닌가?'** 라는 방향으로 고민하면 반례를 찾을 수도 있다.

- 투 포인터
  - 엄밀히 따지면 슬라이딩 윈도우는 배열의 크기가 고정적인 상태이고 투 포인터는 아닌 상태로 이 둘을 구분하기도 한다. 
  - 다만 굳이 이 둘을 구분해서 이해할 필요 없을듯
  - 하나의 정렬된 배열에서 두개의 포인트를 잡고 두 포인트가 가리키는 값을 피연산자로 두어 연산을 한 값이 문제에서 주어진 기준에 적합하냐 아니냐에 따라 포인트를 조정함
  - 완탐으로 접근하면 2중for문을 떠올릴텐데 당연히 시간초과나고, 투 포인터를 사용할시 한번의 반복문으로 해결가능

- **트리와 그래프 종합 전략**
     - 트리 : 사이클이 없는 무방향 그래프
     - 그래프에서 되는건 트리에서도 됨.
     - 가중치가 1인 그래프는 bfs, dfs 떠올리고,
     - 가중치가 2 이상 그래프 중 두 정점 사이의 최소 비용 문제는 다익스트라, 모든 정점 쌍의 최소 비용 문제는 플로이드
     - 다만 가중치가 2 이상이여도 트리에서는 임의의 두 정점 사이의 거리가 유일하게 결정되기에 bfs도 가능 [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/blob/8dbdf8e1fc3f2a1d2aec106848057fb400392505/%EB%B0%B1%EC%A4%80/Gold/1240.%E2%80%85%EB%85%B8%EB%93%9C%EC%82%AC%EC%9D%B4%EC%9D%98%E2%80%85%EA%B1%B0%EB%A6%AC/README.md)
     - 사이클 없는 방향 그래프라면 위상정렬
     - 그 밖에 트리에서의 부모배열 채우기, 자식 배열 채우기는 알아둬야 하고, 추가로 최소 신장 트리도...

- 트리
  - 루트에서 bfs를 돌릴 경우 depth 순서대로 방문을 한다.(= 레벨 순회)
  - 이를 이용해, bfs를 돌며 각 노드의 부모배열과 depth 배열을 채울 수 있다.
  - 트리의 부모 배열 채우기 [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Silver/11725.%E2%80%85%ED%8A%B8%EB%A6%AC%EC%9D%98%E2%80%85%EB%B6%80%EB%AA%A8%E2%80%85%EC%B0%BE%EA%B8%B0)
  - 트리는 자료구조중 하나이기에, 사실 트리를 바탕으로 나올 수 있는 문제 유형은 무궁무진
  - 트리 + 재귀 문제. 
     - 이진검색트리이고 입력값이 무작위일떄 후위순회를 출력하라든가 [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/90478d645e427fa6cab82e94d23ce756da09ccbc/%EB%B0%B1%EC%A4%80/Gold/26260.%E2%80%85%EC%9D%B4%EA%B0%80%E2%80%85%EB%B9%A0%EC%A7%84%E2%80%85%EC%9D%B4%EC%A7%84%E2%80%85%ED%8A%B8%EB%A6%AC)
     - 이진트리인데 pre, in 주어질떄 post 출력하라든가 [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Gold/4256.%E2%80%85%ED%8A%B8%EB%A6%AC)
     - 이진트리인데 post, in 주어질때 pre 출력하라든가 [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/184309b1530c790f17fa7d0f7f9435f85a191e43/%EB%B0%B1%EC%A4%80/Gold/2263.%E2%80%85%ED%8A%B8%EB%A6%AC%EC%9D%98%E2%80%85%EC%88%9C%ED%9A%8C)
     - 결국 트리의 성격에 따라, 주어진 순회의 특성에 따라 root를 찾고 이것을 기준으로 분할정복 식으로 재귀 돌리면 돼.
  - 트리 + DP 문제 [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/774914d0ef4f3019f68402e8dbd151313c81f06c/%EB%B0%B1%EC%A4%80/Gold/2533.%E2%80%85%EC%82%AC%ED%9A%8C%EB%A7%9D%E2%80%85%EC%84%9C%EB%B9%84%EC%8A%A4%EF%BC%88SNS%EF%BC%89)
  - 트라이.
  - 최소 공통 조상.
  
- 이진 트리
     - 이진 트리의 경우 입력을 받을 때 lc[x](= x 노드의 왼쪽 자식 노드 값), rc[x] 배열을 채우면 클래스를 정의할 필요 없이 진행할 수 있다.
     - 이진 트리의 전위, 중위, 후위 순회 [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Silver/1991.%E2%80%85%ED%8A%B8%EB%A6%AC%E2%80%85%EC%88%9C%ED%9A%8C)
     - 이진 트리의 전위순회 결과가 주어졌을때 후위순회 결과를 출력하는 [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Gold/5639.%E2%80%85%EC%9D%B4%EC%A7%84%E2%80%85%EA%B2%80%EC%83%89%E2%80%85%ED%8A%B8%EB%A6%AC)

- 이진 검색 트리 ( = 이진 탐색 트리)
  - 왼쪽 서브트리의 모든 값이 부모노드 보다 작고, 오른쪽 서브트리의 모든 요소 값들이 부모노드 보다 작은 이진 트리
  - 일반 배열보다 삽입 삭제 조회가 빠름. O(lgN)
  - 해시는 값을 정렬 안해주지만 얘는 정렬해줌.
  - 여태 map을 해시로 알고 있었는데, 이진검색트리였음..
  - 해시로 구현한 C++ STL : unordered_set, unordered_multiset, unordered_map
  - 이진검색트리로 구현한 C++ STL : set, multiset, map
  - 엄밀히 말하면 그냥 이진검색트리가 아니라 균형잡힌 이진검색 트리임. 
  - 그 중 내가 구현해본 모델로 AVL가 있는데, C++에서는 AVL이 아니라 레드블랙트리로 구현함. 이게 더 성능 좋으니.
  - [모범 예제1](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Gold/7662.%E2%80%85%EC%9D%B4%EC%A4%91%E2%80%85%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%E2%80%85%ED%81%90), [모범 예제2](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Gold/1202.%E2%80%85%EB%B3%B4%EC%84%9D%E2%80%85%EB%8F%84%EB%91%91)

- 유니온 파인드 ( = 합집합 찾기 = 서로소 집합 알고리즘 = 분리 집합)
     - getParent(int x), unionParent(int x, int y), isSameParent(int x, int y) 이 세 가지 함수를 구현
     - 부모 정점을 저장하는 p[x] 테이블을 위의 함수로 갱신하여 해당 정점이 같은 부모를 공유 하나 안하나를 확인하는 알고리즘
     - [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/88ff989c5957ecfa5a91962feb39b21952b5f394/%EB%B0%B1%EC%A4%80/Gold/1717.%E2%80%85%EC%A7%91%ED%95%A9%EC%9D%98%E2%80%85%ED%91%9C%ED%98%84)

- 최소 신장 트리 ( = 최소 스패닝 트리)
  - 신장 트리 중 가중치의 총합이 최소값을 이루는 트리
  - 크루스칼 알고리즘 + 유니온 파인드 알고리즘으로 푼다.
  - 간선의 가중치를 오름차순으로 정렬한뒤, 가장 값이 작은 가중치를 갖는 간선부터 하나씩 추가한다.
  - 이때 사이클이 형성되나 안되나 확인하는데 사이클이 형성되면 간선을 더한것을 취소하고 사이클이 형성 안되면 확정한다. 
  - 확인하는 방법은 유니온 파인드를 활용한다.
  - 완성된 최소 스패닝 트리 특성상 간선의 개수가 정점의 개수보다 하나가 작다.
  - 떄문에 추가된 간선의 개수 정점의 개수보다 하나가 적은 시점까지 사이클이 형성되지 않도록 간선을 추가하는 과정을 밟으면 된다.
  - [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Gold/1197.%E2%80%85%EC%B5%9C%EC%86%8C%E2%80%85%EC%8A%A4%ED%8C%A8%EB%8B%9D%E2%80%85%ED%8A%B8%EB%A6%AC)

- 위상 정렬
  - **사이클이 없는 방향 그래프**에서 선후 관계의 모순 없이 나열하는 것
  - 사이클이 없는 무방향(=양방향) 그래프를 트리라고 하고, 사이클이 없는 방향 그래프는 DAG라 함
  - 때문에 위상 정렬을 돌려 결과 배열을 나열하면 전체 정점 개수와 크기 비교를 통해 사이클이 있는지 없는지도 판단할 수 있음.
  - 구현 방법
    1. 입력을 받을때 배열 deg[x](정점 x의 indegree값)을 갱신, adj[x] 갱신
    2. deg[x]==0 인 x 값들 큐에 넣음
    3. 큐에서 정점 꺼내면서 result 배열에 해당 정점 넣어주고, 해당 정점과 연결된 정점들의 deg[nx] 값 1씩 빼줌
    4. 1을 뺄때 값이 0이 되는 정점은 큐에 넣어줌
    5. c~d번 반복
  - [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Gold/2252.%E2%80%85%EC%A4%84%E2%80%85%EC%84%B8%EC%9A%B0%EA%B8%B0)

- 플로이드 알고리즘
  - **그래프**에서 모든 쌍의 최단 거리와 그것의 경로를 O(V^3)로 구하는 알고리즘
  - 시간 복잡도가 높아서, 정점의 수가 1000개는 상황에 따라 아슬아슬하고, 500개 정도면 충분히 가능
  - 음수 간선 가능, 음수 사이클 불가능
  - 최단 거리 구현 방법
    1. cost[i][j] = i 정점에서 j 정점까지 가는데 드는 최소 비용. 을 나타내는 이 테이블을 갱신해줄거야
    2. 처음 테이블의 모든 요소를 1e9로 갱신. 두 요소를 더하는 상황도 있기에 2e9로 하지 않음.
    3. 자기 자신까지 가는데는 0으로 갱신
    4. 바로 인접한 정점까지의 비용만 입력을 받으면서 갱신
    5. 정점을 하나씩 정해주면서, 해당 정점을 거쳐가는 경우의 비용과 거쳐가지 않는 기존의 비용과 대소 비교를 통해 작은쪽으로 갱신
        - a = min(a, b); 는 매번 대입을 하기 때문에, if(a > b) a = b; 라고 하는 편이 성능면에서 이득
    6. d번 에서 결국 3중 for문을 돌게 되는데, 이때 거쳐갈 정점을 맨 바깥으로 빼놔야돼.
  - [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Gold/11404.%E2%80%85%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)
  - 경로 복원 구현 방법
    1. nxt[i][j] = i 정점에서 j 정점까지 최소 비용으로 갈때, i에서 이동하는 그 다음 정점
    2. 바로 인접한 정점까지의 입력을 받을때 1차로 갱신
    3. k 정점을 거쳐가는 경우의 비용이 작을때, nxt[i][j] = nxt[i][k]로 갱신
    4. i에서 j까지의 경로 담는법 : while(st != j) { path.push_back(st); st = nxt[st][j]; } path.push_back(j);
  - [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Gold/11780.%E2%80%85%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%E2%80%852)
  

- 다익스트라
  - **가중치가 2 이상인 그래프**에서 한 정점에서 시작하여 다른 모든 정점까지의 최단 경로를 찾는 알고리즘
  - 음수 간선 불가능 (음수 간선이 있는 경우에는 벨만포드 알고리즘 사용)
  - [개념강의](https://www.youtube.com/watch?v=611B-9zk2o4&ab_channel=%EB%8F%99%EB%B9%88%EB%82%98)
  - 작동 원리
    1. 출발 노드를 설정
    2. 출발 노드를 기준으로 인접 노드의 최소비용을 저장 (인접 노드로 방문한게 아직 아니라, 인접노드까지 가는데 얼마만큼의 비용이 드는지만 확인하는 과정)
    3. 방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택
    4. 해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하여 최소 비용을 갱신
    5. 위 과정에서 3번~4번을 반복합니다.
  - [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Gold/1753.%E2%80%85%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C)

- KMP 알고리즘 (코테에 나올 확률 매우 적음)
     - 이해 못함
     - 단순히 부분 문자열이 있냐 없냐만 확인할거라면 strstr 함수 활용해. 시간복잡도 O(N+M)
     - [strstr 활용한 모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Bronze/16916.%E2%80%85%EB%B6%80%EB%B6%84%E2%80%85%EB%AC%B8%EC%9E%90%EC%97%B4)
     - 그런게 아니라 조금 더 응용해야 되는 상황이면 str.find() 쓰고. 시간복잡도 O(N*M)
     - 시간초과 뜨면 문제 포기해.
     - find를 활용하여 부분 문자열이 몇개 들어있는지 찾기
     - ``` 
       while(1) {
            int findedIdx = str.find(pattern, idx);
            if(findedIdx == -1) break;
            idx = findedIdx + pattern.size();
            cnt++;
       }
       ```
     - map이나 set, hash 값을 이용하는 다른 방법이 없을까 고민해봤는데 결국 for문 안에서 substr을 만들어서 그걸 map에 넣거나 hash값을 만들어서 패턴과 비교하는건데, for문이 O(N), substr은 O(M) 이라, find 쓰는거랑 별 차이 없는듯.
     - Rabin-karp가 시간복잡도가 O(N)인, 해쉬값을 활용한 알고리즘 이라는데,,, 나중에 다시 보자.

- 트라이
     - 문자열을 저장할 수 있는 트리 자료구조
     - 단순 문자열 삽입/삭제/조회 할때는 그냥 시간상 공간상 map 쓰는게 훨씬 이득
     - 다만, 트라이를 써야만 풀리는 문제들이 있어. 자동완성기능처럼 접두사, 접미사를 가지고 이래저래 해야 하는 문제들.
     - [트라이 구현](https://github.com/Joshua-Shin/Algorithm-BaekJoon/blob/main/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B5%AC%ED%98%84%ED%95%A8%EC%88%98/%ED%8A%B8%EB%9D%BC%EC%9D%B4.cpp)
     - [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Silver/14425.%E2%80%85%EB%AC%B8%EC%9E%90%EC%97%B4%E2%80%85%EC%A7%91%ED%95%A9)
     
-----------------------------
### 유명 문제별 풀이전략
- LCS
     - Longest Common Subsuquence 최장 공통 부분수열을 구하는 문제.
     - DP로 해결
     - 길이를 구할때,
     - if(a[x]==b[y]) dp(x, y) = dp(x+1, y+1) + 1;
     - else dp(x, y) = max(dp(x, y+1), dp(x+1, y));
     - 구한 수열을 출력해야 할때,
     - if(cache[x][y]==cache[x][y+1]) y++; else if(cache[x][y]==cache[x+1][y]) x++; else ans += a[x]; x++; y++;
     - [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/main/%EB%B0%B1%EC%A4%80/Gold/9252.%E2%80%85LCS%E2%80%852)
- LIS
     - dp로 푸는 방법과 이분탐색으로 푸는 방법이 있는데, 무조건 이분탐색으로 풀어.
     - 길이만 구하면 되는 경우와 길이 + 추적해야되는 상황이 있는데, 어떤 상황이든 이분탐색으로 다 가능.
     - 추적할때, stack, set, vector에 담아 reverse하기 다 해봤는데, set이 제일 느리고 stack이랑 vector가 거의 성능 비슷.
     - [모범 예제](https://github.com/Joshua-Shin/Algorithm-BaekJoon/tree/385ccb00381fdb5d32cfd13203b6bda462830a34/%EB%B0%B1%EC%A4%80/Platinum/14003.%E2%80%85%EA%B0%80%EC%9E%A5%E2%80%85%EA%B8%B4%E2%80%85%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94%E2%80%85%EB%B6%80%EB%B6%84%E2%80%85%EC%88%98%EC%97%B4%E2%80%855)
